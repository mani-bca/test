I'll provide you with steps to install MetalLB and set up an IP pool on KillerCoda, followed by a demo for path-based routing using NGINX Ingress.

# MetalLB and NGINX Ingress Path-Based Routing Setup Guide

This guide provides steps to install MetalLB for load balancing and NGINX Ingress Controller for path-based routing in a Kubernetes environment like KillerCoda.

## Part 1: Install MetalLB Load Balancer

### Step 1: Install MetalLB using Manifest

```bash
# Check if IPVS is enabled (recommended for MetalLB)
kubectl -n kube-system describe configmap kube-proxy

# Create metallb namespace
kubectl create namespace metallb-system

# Deploy MetalLB components
kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.13.10/config/manifests/metallb-native.yaml

# Verify MetalLB pods are running
kubectl get pods -n metallb-system
```

### Step 2: Configure IP Address Pool for MetalLB

First, determine the IP range available for your KillerCoda environment:

```bash
# Check the node's IP range
ip a

# Create the IPAddressPool and L2Advertisement resources
```

Create a file named `metallb-config.yaml`:

```yaml
apiVersion: metallb.io/v1beta1
kind: IPAddressPool
metadata:
  name: first-pool
  namespace: metallb-system
spec:
  addresses:
  - 172.30.1.100-172.30.1.120  # Adjust this range to match your KillerCoda environment
---
apiVersion: metallb.io/v1beta1
kind: L2Advertisement
metadata:
  name: l2-advert
  namespace: metallb-system
spec:
  ipAddressPools:
  - first-pool
```

Apply the configuration:

```bash
kubectl apply -f metallb-config.yaml

# Verify the IP address pool
kubectl get ipaddresspools.metallb.io -n metallb-system
kubectl get l2advertisements.metallb.io -n metallb-system
```

## Part 2: Install NGINX Ingress Controller

```bash
# Install NGINX Ingress Controller using Helm
helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm repo update
helm install nginx-ingress ingress-nginx/ingress-nginx \
  --namespace ingress-nginx \
  --create-namespace \
  --set controller.service.type=LoadBalancer

# Verify the installation
kubectl get pods -n ingress-nginx
kubectl get svc -n ingress-nginx
```

Wait until the NGINX Ingress controller receives an external IP from MetalLB:

```bash
kubectl get svc -n ingress-nginx
```

Make note of the EXTERNAL-IP assigned to the nginx-ingress-controller service.

## Part 3: Deploy Demo Applications for Path-Based Routing

### Step 1: Create Demo Applications

Create a file named `demo-apps.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app1
spec:
  replicas: 1
  selector:
    matchLabels:
      app: app1
  template:
    metadata:
      labels:
        app: app1
    spec:
      containers:
      - name: app1
        image: hashicorp/http-echo
        args:
          - "-text=App 1"
        ports:
        - containerPort: 5678
---
apiVersion: v1
kind: Service
metadata:
  name: app1-service
spec:
  selector:
    app: app1
  ports:
  - port: 80
    targetPort: 5678
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app2
spec:
  replicas: 1
  selector:
    matchLabels:
      app: app2
  template:
    metadata:
      labels:
        app: app2
    spec:
      containers:
      - name: app2
        image: hashicorp/http-echo
        args:
          - "-text=App 2"
        ports:
        - containerPort: 5678
---
apiVersion: v1
kind: Service
metadata:
  name: app2-service
spec:
  selector:
    app: app2
  ports:
  - port: 80
    targetPort: 5678
```

Apply the configuration:

```bash
kubectl apply -f demo-apps.yaml

# Verify that the pods are running
kubectl get pods
kubectl get svc
```

### Step 2: Create Ingress Resource for Path-Based Routing

Create a file named `path-based-ingress.yaml`:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: path-based-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx
  rules:
  - http:
      paths:
      - path: /app1
        pathType: Prefix
        backend:
          service:
            name: app1-service
            port:
              number: 80
      - path: /app2
        pathType: Prefix
        backend:
          service:
            name: app2-service
            port:
              number: 80
```

Apply the configuration:

```bash
kubectl apply -f path-based-ingress.yaml

# Verify the Ingress resource
kubectl get ingress
```

## Part 4: Testing the Path-Based Routing

Get the external IP address of the NGINX Ingress controller:

```bash
kubectl get svc -n ingress-nginx
```

Test the path-based routing:

```bash
# Test app1 path
curl http://<EXTERNAL-IP>/app1

# Test app2 path
curl http://<EXTERNAL-IP>/app2
```

If you're using KillerCoda and can't directly curl, you may need to set up port forwarding or use the KillerCoda web interface to access the applications.

## Troubleshooting

### Check MetalLB status
```bash
kubectl logs -n metallb-system -l app=metallb
kubectl describe ipaddresspools.metallb.io -n metallb-system
```

### Check NGINX Ingress status
```bash
kubectl logs -n ingress-nginx -l app.kubernetes.io/name=ingress-nginx
kubectl describe ingress path-based-ingress
```

### Check endpoints
```bash
kubectl get endpoints app1-service
kubectl get endpoints app2-service
```

## Advanced Configuration: TLS with Self-Signed Certificate

### Generate a self-signed certificate
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  -keyout tls.key -out tls.crt -subj "/CN=example.com"

# Create a TLS secret
kubectl create secret tls example-tls --key tls.key --cert tls.crt
```

### Update Ingress to use TLS
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: path-based-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx
  tls:
  - hosts:
      - example.com
    secretName: example-tls
  rules:
  - host: example.com
    http:
      paths:
      - path: /app1
        pathType: Prefix
        backend:
          service:
            name: app1-service
            port:
              number: 80
      - path: /app2
        pathType: Prefix
        backend:
          service:
            name: app2-service
            port:
              number: 80
```

#!/bin/bash

# Colors for better readability
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print section headers
print_header() {
    echo -e "\n${BLUE}==================================================================${NC}"
    echo -e "${YELLOW}$1${NC}"
    echo -e "${BLUE}==================================================================${NC}\n"
}

# Function to wait for resource
wait_for_resource() {
    resource_type=$1
    resource_name=$2
    namespace=${3:-default}
    
    echo -e "Waiting for $resource_type/$resource_name to be ready..."
    
    while true; do
        if [ "$resource_type" == "deployment" ]; then
            status=$(kubectl -n $namespace get deployment $resource_name -o jsonpath='{.status.availableReplicas}')
            if [ "$status" != "" ] && [ "$status" != "0" ]; then
                echo -e "${GREEN}✓ $resource_type/$resource_name is ready!${NC}"
                break
            fi
        elif [ "$resource_type" == "pod" ]; then
            status=$(kubectl -n $namespace get pods -l app=$resource_name -o jsonpath='{.items[0].status.phase}')
            if [ "$status" == "Running" ]; then
                echo -e "${GREEN}✓ $resource_type/$resource_name is ready!${NC}"
                break
            fi
        fi
        echo -n "."
        sleep 2
    done
}

# Start the demo
print_header "Starting MetalLB and NGINX Ingress Path-Based Routing Demo"

# Step 1: Set up MetalLB
print_header "Step 1: Installing MetalLB"
kubectl create namespace metallb-system
kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.13.10/config/manifests/metallb-native.yaml

echo "Waiting for MetalLB components to be ready..."
sleep 10

# Get the available IP range
print_header "Checking available IP range for MetalLB"
echo "Current node IP configuration:"
ip a | grep -E "eth0|ens|enp" -A2

# Create MetalLB config based on KillerCoda environment
# Typically KillerCoda nodes use 172.30.1.X range
cat <<EOF > metallb-config.yaml
apiVersion: metallb.io/v1beta1
kind: IPAddressPool
metadata:
  name: first-pool
  namespace: metallb-system
spec:
  addresses:
  - 172.30.1.100-172.30.1.120  # Adjust if necessary for your environment
---
apiVersion: metallb.io/v1beta1
kind: L2Advertisement
metadata:
  name: l2-advert
  namespace: metallb-system
spec:
  ipAddressPools:
  - first-pool
EOF

kubectl apply -f metallb-config.yaml
echo -e "${GREEN}✓ MetalLB config applied${NC}"

# Step 2: Install NGINX Ingress Controller
print_header "Step 2: Installing NGINX Ingress Controller"
kubectl create namespace ingress-nginx
helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm repo update
helm install nginx-ingress ingress-nginx/ingress-nginx \
  --namespace ingress-nginx \
  --set controller.service.type=LoadBalancer

echo "Waiting for NGINX Ingress Controller to be ready..."
sleep 20

# Check if NGINX Ingress service got an external IP
ext_ip=$(kubectl get svc -n ingress-nginx nginx-ingress-ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
if [ -z "$ext_ip" ]; then
    echo "No external IP assigned yet, waiting longer..."
    sleep 20
    ext_ip=$(kubectl get svc -n ingress-nginx nginx-ingress-ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
    if [ -z "$ext_ip" ]; then
        echo "Still no external IP, using nodePort instead as fallback..."
        node_ip=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
        node_port=$(kubectl get svc -n ingress-nginx nginx-ingress-ingress-nginx-controller -o jsonpath='{.spec.ports[0].nodePort}')
        ext_ip="${node_ip}:${node_port}"
    fi
fi

print_header "Step 3: Deploying demo applications"

# Create app1 deployment and service
cat <<EOF > app1.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app1
spec:
  replicas: 1
  selector:
    matchLabels:
      app: app1
  template:
    metadata:
      labels:
        app: app1
    spec:
      containers:
      - name: app1
        image: hashicorp/http-echo
        args:
          - "-text=Hello from App 1"
        ports:
        - containerPort: 5678
---
apiVersion: v1
kind: Service
metadata:
  name: app1-service
spec:
  selector:
    app: app1
  ports:
  - port: 80
    targetPort: 5678
EOF

kubectl apply -f app1.yaml
wait_for_resource